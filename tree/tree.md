# 二叉树

## 知识点划分

1. 树的遍历
2. 树的构建
3. 树的修改

## 树的遍历

### 深度优先

深度优先可以分为前序、中序、后序
也可以分成递归写法和栈写法

掌握以下几种基本写法:

1. 前序、后续遍历的写法
2. 二叉搜索树的中序遍历
3. 路径和相关

常见题型：

1. 树的判断: 相同树、对称树、翻转树
1. 路径(和): 所有路径、最大路径、路径和为某个值得路径
1. 二叉搜索树的中序遍历: 二叉搜索树中序遍历默认是有序的

### 广度优先

广度优先搜索的一个例子是层序遍历,从根节点开始依次向下搜索。一般是用队列实现的
tips: 广度优先是按层遍历的,每一层做单独存储,方便使用: [[level1], [level2]]

1. bfs 基本写法

bfs 的核心是维护一个队列,每层开始遍历的时候记录长度,然后取出元素,添加到 levelArr 中
遍历最终结果是一个二维数组,每一层都是一个单独的 levelArr

2. 常见题型:

- 层序遍历、反层序遍历、锯齿遍历: 重点是加入 levelArr 的方式 push OR unshift
- 深度相关：最小深度、最大深度、平均深度

## 技巧

1. dfs 类的题目不管目标是什么，先遍历，遍历的过程中思考目标是什么。
2. dfs 类的题目多思考参数传递：比如在路径问题上，递归传递 path 表示当前节点的路径
3. dfs 类的题目多思考返回值,比如在后续遍历的题目上,返回值其实就是子节点状态,和参数有类似的效果
4. 前/中/后序的遍历路径是一致的,区别是记录的 timing,第一次访问就记录的是前序,第二次是中序,第三次是后续
5. 前中后也可以按压栈、弹栈来理解,压栈记录是前序,第一次弹栈时记录是中序,第二次弹栈时记录是后续
6. 标志位的使用,因为树是递归的结构,子树条件不符合会导致包含该子树的所有树都不符合,这种题目里我们可以使用一个标志位,比如常见的-1,递归时如果子树有-1 可以直接避免计算,直接返回-1 向上传递;标志位一般用在 dfs 中,dfs 对当前节点的访问一共有三次机会,可以在第三次访问的时候根据前面 2 次访问的信息,决定当前是否需要再访问

## 树的修改

TODO:

## 树的构建

1. 中序 + 前序/后续遍历构建: 通过前序/后续拿到根节点,然后在中序中区分左右子树,再回到前序/后续找到分界点,然后递归即可。
2. 前序 + 后序构建: TODO:

## TODO:

1. 整理路径和的相关题型: 简单/中等/难都有
2. 树的后续遍历写法
3. 树的递归: 有些题型遇到还是不稳,比如二叉树的最近公共祖先(235 和 236)
4. 树的修改: 感觉概率不大
